
//https://github.com/TwoTailsGames/Unity-Built-in-Shaders/blob/master/CGIncludes/UnityCG.cginc
//From UnityCG.cginc

#define UNITY_PI            3.14159265359f
#define UNITY_TWO_PI        6.28318530718f

//This acts like a bias for the surface tracing function, 1 gives best results.
//Though this can cause issues with thin geometry (i.e. things that are only represented as a single voxel and no neighboring ones)
//TODO: With voxelization, introduce an adjustable thickness modifier when generating them for the scene.
#define SURFACE_OCCLUSION_SKIP_ITERATION 1

//|||||||||||||||||||||||||||||||||||||| KEYWORDS ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| KEYWORDS ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| KEYWORDS ||||||||||||||||||||||||||||||||||||||

#pragma multi_compile_local _ DIRECTIONAL_LIGHTS
#pragma multi_compile_local _ POINT_LIGHTS
#pragma multi_compile_local _ SPOT_LIGHTS
#pragma multi_compile_local _ AREA_LIGHTS

//|||||||||||||||||||||||||||||||||||||| STRUCTS ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| STRUCTS ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| STRUCTS ||||||||||||||||||||||||||||||||||||||

#if defined (DIRECTIONAL_LIGHTS)
struct LightDirectional
{
    float3 lightDirection;
    float3 lightColor;
    float lightIntensity;
};
#endif

#if defined (POINT_LIGHTS)
struct LightPoint
{
    float3 lightPosition;
    float3 lightColor;
    float lightIntensity;
    float lightRange;
};
#endif

#if defined (SPOT_LIGHTS)
struct LightSpot
{
    float3 lightPosition;
    float3 lightDirection;
    float3 lightColor;
    float lightIntensity;
    float lightRange;
    float lightAngle;
};
#endif

#if defined (SPOT_LIGHTS)
struct LightArea
{
    float3 lightPosition;
    float3 lightForwardDirection;
    float3 lightRightDirection;
    float3 lightUpwardDirection;
    float2 lightSize;
    float3 lightColor;
    float lightIntensity;
    float lightRange;
};
#endif

//|||||||||||||||||||||||||||||||||||||| VARIABLES ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| VARIABLES ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| VARIABLES ||||||||||||||||||||||||||||||||||||||

SamplerState _PointClamp;
SamplerState _LinearClamp;

Texture3D<float4> SceneAlbedo;
Texture3D<float4> SceneEmissive;
RWTexture3D<float4> Write;

float3 VolumePosition;
float3 VolumeSize;
float3 VolumeResolution;

int Samples;
int Bounces;

float _Seed;

#if defined (DIRECTIONAL_LIGHTS)
RWStructuredBuffer<LightDirectional> DirectionalLights;
#endif

#if defined (POINT_LIGHTS)
RWStructuredBuffer<LightPoint> PointLights;
#endif

#if defined (SPOT_LIGHTS)
RWStructuredBuffer<LightSpot> SpotLights;
#endif

#if defined (SPOT_LIGHTS)
RWStructuredBuffer<LightArea> AreaLights;
#endif

//|||||||||||||||||||||||||||||||||||||| TEXTURE SAMPLING ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| TEXTURE SAMPLING ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| TEXTURE SAMPLING ||||||||||||||||||||||||||||||||||||||

float4 TEX2D_SHARP(Texture2D<float4> tex, float2 uv)
{
    return tex.SampleLevel(_PointClamp, uv, 0);
}

float4 TEX3D_SHARP(Texture3D<float4> tex, float3 position)
{
    return tex.SampleLevel(_PointClamp, position, 0);
}

float4 TEX2D(Texture2D<float4> tex, float2 uv)
{
    return tex.SampleLevel(_LinearClamp, uv, 0);
}

float4 TEX3D(Texture3D<float4> tex, float3 position)
{
    return tex.SampleLevel(_LinearClamp, position, 0);
}

//||||||||||||||||||||||||||||| RANDOM FUNCTIONS |||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||| RANDOM FUNCTIONS |||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||| RANDOM FUNCTIONS |||||||||||||||||||||||||||||

// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.
uint JenkinsHash(uint x)
{
    x += (x << 10u);
    x ^= (x >> 6u);
    x += (x << 3u);
    x ^= (x >> 11u);
    x += (x << 15u);
    return x;
}

// Compound versions of the hashing algorithm.
uint JenkinsHash(uint2 v)
{
    return JenkinsHash(v.x ^ JenkinsHash(v.y));
}

uint JenkinsHash(uint3 v)
{
    return JenkinsHash(v.x ^ JenkinsHash(v.yz));
}

uint JenkinsHash(uint4 v)
{
    return JenkinsHash(v.x ^ JenkinsHash(v.yzw));
}

// Construct a float with half-open range [0, 1) using low 23 bits.
// All zeros yields 0, all ones yields the next smallest representable value below 1.
float ConstructFloat(int m) 
{
    const int ieeeMantissa = 0x007FFFFF; // Binary FP32 mantissa bitmask
    const int ieeeOne = 0x3F800000; // 1.0 in FP32 IEEE

    m &= ieeeMantissa;                   // Keep only mantissa bits (fractional part)
    m |= ieeeOne;                        // Add fractional part to 1.0

    float  f = asfloat(m);               // Range [1, 2)
    return f - 1;                        // Range [0, 1)
}

float ConstructFloat(uint m)
{
    return ConstructFloat(asint(m));
}

// Pseudo-random value in half-open range [0, 1). The distribution is reasonably uniform.
// Ref: https://stackoverflow.com/a/17479300
float GenerateHashedRandomFloat(uint x)
{
    return ConstructFloat(JenkinsHash(x));
}

float GenerateHashedRandomFloat(uint2 v)
{
    return ConstructFloat(JenkinsHash(v));
}

float GenerateHashedRandomFloat(uint3 v)
{
    return ConstructFloat(JenkinsHash(v));
}

float GenerateHashedRandomFloat(uint4 v)
{
    return ConstructFloat(JenkinsHash(v));
}

float GenerateRandomFloat(float2 screenUV)
{
    _Seed += 1.0;
    //return GenerateHashedRandomFloat(uint3(screenUV * _ScreenParams.xy, _Seed));
    return GenerateHashedRandomFloat(uint3(screenUV, _Seed));
}

//||||||||||||||||||||||||||||| CLASSIC RANDOM FUNCTIONS |||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||| CLASSIC RANDOM FUNCTIONS |||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||| CLASSIC RANDOM FUNCTIONS |||||||||||||||||||||||||||||

float hash(float2 p)  // replace this by something better
{
    p = 50.0 * frac(p * 0.3183099 + float2(0.71, 0.113));
    return -1.0 + 2.0 * frac(p.x * p.y * (p.x + p.y));
}

float rand(float co) 
{ 
    return frac(sin(co * (91.3458)) * 47453.5453); 
}

float rand(float2 co) 
{ 
    return frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453); 
}

float rand(float3 co) 
{ 
    return rand(co.xy + rand(co.z)); 
}

//||||||||||||||||||||||||||||| SAMPLING FUNCTIONS |||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||| SAMPLING FUNCTIONS |||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||| SAMPLING FUNCTIONS |||||||||||||||||||||||||||||

// Assumes that (0 <= x <= Pi).
float SinFromCos(float cosX)
{
    return sqrt(saturate(1 - cosX * cosX));
}

// Transforms the unit vector from the spherical to the Cartesian (right-handed, Z up) coordinate.
float3 SphericalToCartesian(float cosPhi, float sinPhi, float cosTheta)
{
    float sinTheta = SinFromCos(cosTheta);

    return float3(float2(cosPhi, sinPhi) * sinTheta, cosTheta);
}

float3 SphericalToCartesian(float phi, float cosTheta)
{
    float sinPhi, cosPhi;
    sincos(phi, sinPhi, cosPhi);

    return SphericalToCartesian(cosPhi, sinPhi, cosTheta);
}

float3 SampleSphereUniform(float u1, float u2)
{
    float phi = UNITY_TWO_PI * u2;
    float cosTheta = 1.0 - 2.0 * u1;

    return SphericalToCartesian(phi, cosTheta);
}

// Cosine-weighted sampling without the tangent frame.
// Ref: http://www.amietia.com/lambertnotangent.html
float3 SampleHemisphereCosine(float u1, float u2, float3 normal)
{
    // This function needs to used safenormalize because there is a probability
    // that the generated direction is the exact opposite of the normal and that would lead
    // to a nan vector otheriwse.
    float3 pointOnSphere = SampleSphereUniform(u1, u2);
    return normalize(normal + pointOnSphere);
}

//||||||||||||||||||||||||||||| OTHER FUNCTIONS |||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||| OTHER FUNCTIONS |||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||| OTHER FUNCTIONS |||||||||||||||||||||||||||||

float3 GetRandomDirection(float3 direction)
{
    return float3(rand(direction.x), rand(direction.y), rand(direction.z));
}

float CalculateAttenuation(float distanceToSource)
{
    //return 1.0f / (distanceToSource * distanceToSource); //inverse square falloff
    return 1.0f / distanceToSource; //linear falloff;
    //return 1.0f / pow(distanceToSource, 4.0);
}

// Function to estimate the surface normal at a given 3D texture position
float3 EstimateSurfaceNormal(float3 texCoord)
{
    // Compute the step size between neighboring 3D texture samples
    float3 delta = 1.0 / VolumeResolution.xyz;

    // Sample the 3D texture at the current position and its neighboring positions
    float center = TEX3D_SHARP(SceneAlbedo, texCoord).a;
    float dx = TEX3D_SHARP(SceneAlbedo, texCoord + float3(delta.x, 0.0, 0.0)).a;
    float dy = TEX3D_SHARP(SceneAlbedo, texCoord + float3(0.0, delta.y, 0.0)).a;
    float dz = TEX3D_SHARP(SceneAlbedo, texCoord + float3(0.0, 0.0, delta.z)).a;

    // Compute the gradient by subtracting neighboring samples
    float3 gradient = float3(dx - center, dy - center, dz - center);

    // Calculate the surface normal by normalizing the gradient
    float3 normal = normalize(gradient);

    return normal;
}

bool PositionInVolumeBounds(float3 worldPosition)
{
    if (worldPosition.x > VolumePosition.x + VolumeSize.x)
        return false;

    if (worldPosition.x < VolumePosition.x - VolumeSize.x)
        return false;

    if (worldPosition.y > VolumePosition.y + VolumeSize.x)
        return false;

    if (worldPosition.y < VolumePosition.y - VolumeSize.x)
        return false;

    return true;
}

//||||||||||||||||||||||||||||| ComputeShader_TraceVolumeDirectLight_V1 |||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||| ComputeShader_TraceVolumeDirectLight_V1 |||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||| ComputeShader_TraceVolumeDirectLight_V1 |||||||||||||||||||||||||||||

#pragma kernel ComputeShader_TraceVolumeDirectLight_V1
[numthreads(8, 8, 8)]
void ComputeShader_TraceVolumeDirectLight_V1(uint3 id : SV_DispatchThreadID)
{
    float3 voxelPosition = id.xyz + float3(0.5, 0.5, 0.5);
    voxelPosition /= VolumeResolution.xyz;

    float3 singleVoxelSize = VolumeSize / VolumeResolution;

    float3 worldVoxelPosition = VolumePosition + (voxelPosition * VolumeSize) - (VolumeSize / 2.0);

    //buffers
    float4 sceneAlbedo = TEX3D_SHARP(SceneAlbedo, voxelPosition);
    float4 sceneEmissive = TEX3D_SHARP(SceneEmissive, voxelPosition);

    //trace lights
    //float4 finalColor = float4(0, 0, 0, sceneAlbedo.a);
    float4 finalColor = float4(0, 0, 0, 1);

    //|||||||||||||||||||||||||||||||||||| DIRECTIONAL LIGHTS ||||||||||||||||||||||||||||||||||||
    //|||||||||||||||||||||||||||||||||||| DIRECTIONAL LIGHTS ||||||||||||||||||||||||||||||||||||
    //|||||||||||||||||||||||||||||||||||| DIRECTIONAL LIGHTS ||||||||||||||||||||||||||||||||||||
    #if defined (DIRECTIONAL_LIGHTS)
        for (int x = 0; x < DirectionalLights.Length; x++)
        {
            LightDirectional directionalLight = DirectionalLights[x];

            float3 directionalLight_currentRayPosition = worldVoxelPosition;
            float3 directionalLight_currentRayDirection = -directionalLight.lightDirection;
            float3 directionalLight_maxPosition = directionalLight_currentRayPosition + directionalLight.lightDirection * length(VolumeSize);

            directionalLight_maxPosition.x = clamp(directionalLight_maxPosition, VolumeSize.x - VolumePosition, VolumeSize.x + VolumePosition);
            directionalLight_maxPosition.y = clamp(directionalLight_maxPosition, VolumeSize.y - VolumePosition, VolumeSize.y + VolumePosition);
            directionalLight_maxPosition.z = clamp(directionalLight_maxPosition, VolumeSize.z - VolumePosition, VolumeSize.z + VolumePosition);

            float3 directionalLightColorSample = directionalLight.lightColor * directionalLight.lightIntensity;

            //------------------------------ DIRECT LIGHT ------------------------------
            //------------------------------ DIRECT LIGHT ------------------------------
            //------------------------------ DIRECT LIGHT ------------------------------

            bool directionalLight_isOccluded = false;

            //while (distance(directionalLight_currentRayPosition, directionalLight_maxPosition) > 0.5f)
            while (true) //this is fucking dangerous, I don't like this but our breaks appear to work... so let it be for now.
            {
                if (PositionInVolumeBounds(directionalLight_currentRayPosition.xyz) == false)
                    break;

                float3 directionalLight_scaledRayPosition = ((directionalLight_currentRayPosition + (VolumeSize / 2.0)) - VolumePosition) / VolumeSize;
                float4 directionalLight_sceneAlbedoSample = TEX3D_SHARP(SceneAlbedo, directionalLight_scaledRayPosition);

                if (directionalLight_sceneAlbedoSample.a > 0.0)
                {
                    directionalLight_isOccluded = true;
                    break;
                }

                //keep stepping the ray in world space
                //directionalLight_currentRayPosition += directionalLight_currentRayDirection / length(VolumeResolution);
                directionalLight_currentRayPosition += directionalLight_currentRayDirection * singleVoxelSize;
            }

            if (directionalLight_isOccluded == false)
            {
                finalColor.rgb += directionalLightColorSample;
            }
        }
    #endif

    //|||||||||||||||||||||||||||||||||||| SPOT LIGHTS ||||||||||||||||||||||||||||||||||||
    //|||||||||||||||||||||||||||||||||||| SPOT LIGHTS ||||||||||||||||||||||||||||||||||||
    //|||||||||||||||||||||||||||||||||||| SPOT LIGHTS ||||||||||||||||||||||||||||||||||||
    #if defined (SPOT_LIGHTS)
        for (int x = 0; x < SpotLights.Length; x++)
        {
            LightSpot spotLight = SpotLights[x];

            float distanceToSpotLight = distance(worldVoxelPosition, spotLight.lightPosition);
            float spotLightDistanceSample = CalculateAttenuation(distanceToSpotLight);
            float3 spotLightWorldDirection = normalize(worldVoxelPosition - spotLight.lightPosition);

            // Calculate the cosine of the angle corresponding to the spot light's cone angle
            float cosConeAngle = cos(radians(spotLight.lightAngle / 2.0));

            // Calculate the spot light influence (0.0 to 1.0) based on the angle between the light direction and the spotlight direction
            float spotLightAngle = saturate((dot(spotLightWorldDirection, spotLight.lightDirection) - cosConeAngle) / (1.0 - cosConeAngle));

            // Calculate the spot light range influence
            float spotLightRange = saturate(1.0 - (distanceToSpotLight / spotLight.lightRange));

            float3 spotLight_currentRayPosition = worldVoxelPosition;
            float3 spotLight_currentRayDirection = -spotLightWorldDirection;
            float3 spotLightColorSample = spotLight.lightColor * spotLight.lightIntensity;

            //------------------------------ DIRECT LIGHT ------------------------------
            //------------------------------ DIRECT LIGHT ------------------------------
            //------------------------------ DIRECT LIGHT ------------------------------

            bool spotLight_isOccluded = false;
            float3 spotLight_hitPosition = float3(0, 0, 0);
            float3 spotLight_hitNormal = float3(0, 1, 0);
            float3 spotLight_hitAlbedo = float3(1, 1, 1);

            //while (distance(spotLight_currentRayPosition, spotLight.lightPosition) > 0.5f)
            while(true) //this is fucking dangerous, I don't like this but our breaks appear to work... so let it be for now.
            {
                if (PositionInVolumeBounds(spotLight_currentRayPosition.xyz) == false)
                    break;

                float3 spotLight_scaledRayPosition = ((spotLight_currentRayPosition + (VolumeSize / 2.0)) - VolumePosition) / VolumeSize;
                float4 spotLight_sceneAlbedoSample = TEX3D_SHARP(SceneAlbedo, spotLight_scaledRayPosition);

                if (spotLight_sceneAlbedoSample.a > 0.0)
                {
                    //spotLight_hitPosition = spotLight_currentRayPosition;
                    //spotLight_hitNormal = EstimateSurfaceNormal(spotLight_scaledRayPosition);
                    //spotLight_hitAlbedo = spotLight_sceneAlbedoSample.rgb;
                    spotLight_isOccluded = true;
                    break;
                }

                //keep stepping the ray in world space
                //spotLight_currentRayPosition += spotLight_currentRayDirection / length(VolumeResolution);
                spotLight_currentRayPosition += spotLight_currentRayDirection * singleVoxelSize;
            }

            if (spotLight_isOccluded == false)
            {
                //finalColor.rgb += spotLightColorSample * spotLightDistanceSample * spotLightAngle;
                finalColor.rgb += spotLightColorSample * spotLightDistanceSample * spotLightAngle * spotLightRange;
            }
        }
    #endif

    //|||||||||||||||||||||||||||||||||||| POINT LIGHTS ||||||||||||||||||||||||||||||||||||
    //|||||||||||||||||||||||||||||||||||| POINT LIGHTS ||||||||||||||||||||||||||||||||||||
    //|||||||||||||||||||||||||||||||||||| POINT LIGHTS ||||||||||||||||||||||||||||||||||||
    #if defined (POINT_LIGHTS)
        for (int y = 0; y < PointLights.Length; y++)
        {
            LightPoint pointLight = PointLights[y];

            float distanceToPointLight = distance(worldVoxelPosition, pointLight.lightPosition);
            float3 pointLightColorSample = pointLight.lightColor * pointLight.lightIntensity;
            float pointLightDistanceSample = CalculateAttenuation(distanceToPointLight);

            float pointLightRange = saturate(1.0 - (distanceToPointLight / pointLight.lightRange));

            float3 pointLightWorldDirection = normalize(worldVoxelPosition - pointLight.lightPosition);

            float3 pointLight_currentRayPosition = worldVoxelPosition;
            float3 pointLight_currentRayDirection = -pointLightWorldDirection;

            bool pointLight_isOccluded = false;

            //while (distance(pointLight_currentRayPosition, pointLight.lightPosition) > 0.5f)
            while(true) //this is fucking dangerous, I don't like this but our breaks appear to work... so let it be for now.
            {
                if (PositionInVolumeBounds(pointLight_currentRayPosition.xyz) == false)
                    break;

                float3 pointLight_scaledRayPosition = ((pointLight_currentRayPosition + (VolumeSize / 2.0)) - VolumePosition) / VolumeSize;
                float pointLight_sceneOcclusionSample = TEX3D_SHARP(SceneAlbedo, pointLight_scaledRayPosition).a;

                if (pointLight_sceneOcclusionSample > 0.0)
                {
                    pointLight_isOccluded = true;
                    break;
                }

                //keep stepping the ray in world space
                //pointLight_currentRayPosition += pointLight_currentRayDirection / length(VolumeResolution);
                pointLight_currentRayPosition += pointLight_currentRayDirection * singleVoxelSize;
            }

            if (pointLight_isOccluded == false)
            {
                //finalColor.rgb += pointLightColorSample * pointLightDistanceSample;
                finalColor.rgb += pointLightColorSample * pointLightDistanceSample * pointLightRange;
            }
        }
    #endif

    /*
    //|||||||||||||||||||||||||||||||||||| AREA LIGHTS ||||||||||||||||||||||||||||||||||||
    //|||||||||||||||||||||||||||||||||||| AREA LIGHTS ||||||||||||||||||||||||||||||||||||
    //|||||||||||||||||||||||||||||||||||| AREA LIGHTS ||||||||||||||||||||||||||||||||||||
    if (AreaLightsExist)
    {
        for (int z = 0; z < AreaLights.Length; z++)
        {
            LightArea areaLight = AreaLights[z];
            float2 areaLightSize = areaLight.lightSize;
            float3 areaLightForward = areaLight.lightForwardDirection;
            float3 areaLightRight = areaLight.lightRightDirection;
            float3 areaLightUp = areaLight.lightUpwardDirection;

            int areaWidthSamples = areaLightSize.x / min(min(singleVoxelSize.x, singleVoxelSize.y), singleVoxelSize.z);
            int areaHeightSamples = areaLightSize.y / min(min(singleVoxelSize.x, singleVoxelSize.y), singleVoxelSize.z);

            for (int x = 0; x < areaWidthSamples; x++)
            {
                for (int y = 0; y < areaHeightSamples; y++)
                {
                    float3 areaLightSamplePosition = areaLight.lightPosition;
                    areaLightSamplePosition += ((areaLightRight * (x - (areaWidthSamples / 2)))) * singleVoxelSize;
                    areaLightSamplePosition += ((areaLightUp * (y - (areaHeightSamples / 2)))) * singleVoxelSize;

                    float distanceToAreaLight = distance(worldVoxelPosition, areaLightSamplePosition);
                    float areaLightDistanceSample = CalculateAttenuation(distanceToAreaLight);
                    float3 areaLightWorldDirection = normalize(worldVoxelPosition - areaLightSamplePosition);

                    float3 areaLight_currentRayPosition = worldVoxelPosition;
                    float3 areaLight_currentRayDirection = -areaLightWorldDirection;
                    float3 areaLightColorSample = areaLight.lightColor * areaLight.lightIntensity;

                    //------------------------------ DIRECT LIGHT ------------------------------
                    //------------------------------ DIRECT LIGHT ------------------------------
                    //------------------------------ DIRECT LIGHT ------------------------------

                    if (dot(areaLightWorldDirection, areaLightForward) > 0.0)
                    {
                        bool areaLight_isOccluded = false;
                        float3 areaLight_hitPosition = float3(0, 0, 0);
                        float3 areaLight_hitNormal = float3(0, 1, 0);
                        float3 areaLight_hitAlbedo = float3(1, 1, 1);
                    }
                }
            }
        }
    }
    */

    finalColor = max(0.0f, finalColor);

    Write[id.xyz] = finalColor;
}

//||||||||||||||||||||||||||||| ComputeShader_TraceSurfaceDirectLight_V1 |||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||| ComputeShader_TraceSurfaceDirectLight_V1 |||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||| ComputeShader_TraceSurfaceDirectLight_V1 |||||||||||||||||||||||||||||

#pragma kernel ComputeShader_TraceSurfaceDirectLight_V1
[numthreads(8, 8, 8)]
void ComputeShader_TraceSurfaceDirectLight_V1(uint3 id : SV_DispatchThreadID)
{
    float3 voxelPosition = id.xyz + float3(0.5, 0.5, 0.5);
    voxelPosition /= VolumeResolution.xyz;

    float3 singleVoxelSize = VolumeSize / VolumeResolution;

    float3 worldVoxelPosition = VolumePosition + (voxelPosition * VolumeSize) - (VolumeSize / 2.0);

    //buffers
    float4 sceneAlbedo = TEX3D_SHARP(SceneAlbedo, voxelPosition);
    float4 sceneEmissive = TEX3D_SHARP(SceneEmissive, voxelPosition);

    //trace lights
    float4 finalColor = float4(0, 0, 0, 1);
    //float4 finalColor = float4(0, 0, 0, sceneAlbedo.a);

    int iterationIndex = 0;

    //Perform some tests
    //float4 upSample = TEX3D_SHARP(SceneAlbedo, voxelPosition + (normalize(float3(0, 1, 0)) / length(VolumeResolution));
    //float4 downSample = TEX3D_SHARP(SceneAlbedo, voxelPosition + (normalize(float3(0, -1, 0)) / length(VolumeResolution));
    //float4 rightSample = TEX3D_SHARP(SceneAlbedo, voxelPosition + (normalize(float3(1, 0, 0)) / length(VolumeResolution));
    //float4 leftSample = TEX3D_SHARP(SceneAlbedo, voxelPosition + (normalize(float3(-1, 0, 0)) / length(VolumeResolution));
    //float4 forwardSample = TEX3D_SHARP(SceneAlbedo, voxelPosition + (normalize(float3(0, 0, 1)) / length(VolumeResolution));
    //float4 backSample = TEX3D_SHARP(SceneAlbedo, voxelPosition + (normalize(float3(0, 0, -1)) / length(VolumeResolution));

    if (!(sceneAlbedo.a > 0.0))
    {
        Write[id.xyz] = float4(0, 0, 0, 0);
        return;
    }

    //|||||||||||||||||||||||||||||||||||| DIRECTIONAL LIGHTS ||||||||||||||||||||||||||||||||||||
    //|||||||||||||||||||||||||||||||||||| DIRECTIONAL LIGHTS ||||||||||||||||||||||||||||||||||||
    //|||||||||||||||||||||||||||||||||||| DIRECTIONAL LIGHTS ||||||||||||||||||||||||||||||||||||
    #if defined (DIRECTIONAL_LIGHTS)
        for (int x = 0; x < DirectionalLights.Length; x++)
        {
            LightDirectional directionalLight = DirectionalLights[x];

            float3 directionalLight_currentRayPosition = worldVoxelPosition;
            float3 directionalLight_currentRayDirection = -directionalLight.lightDirection;
            float3 directionalLight_maxPosition = directionalLight_currentRayPosition + directionalLight.lightDirection * length(VolumeSize);

            directionalLight_maxPosition.x = clamp(directionalLight_maxPosition, VolumeSize.x - VolumePosition, VolumeSize.x + VolumePosition);
            directionalLight_maxPosition.y = clamp(directionalLight_maxPosition, VolumeSize.y - VolumePosition, VolumeSize.y + VolumePosition);
            directionalLight_maxPosition.z = clamp(directionalLight_maxPosition, VolumeSize.z - VolumePosition, VolumeSize.z + VolumePosition);

            float3 directionalLightColorSample = directionalLight.lightColor * directionalLight.lightIntensity;

            //------------------------------ DIRECT LIGHT ------------------------------
            //------------------------------ DIRECT LIGHT ------------------------------
            //------------------------------ DIRECT LIGHT ------------------------------

            bool directionalLight_isOccluded = false;

            iterationIndex = 0;

            while (true)
            {
                if (PositionInVolumeBounds(directionalLight_currentRayPosition.xyz) == false)
                    break;

                //keep stepping the ray in world space
                //directionalLight_currentRayPosition += directionalLight_currentRayDirection / length(VolumeResolution);
                //directionalLight_currentRayPosition += directionalLight_currentRayDirection / VolumeResolution;
                directionalLight_currentRayPosition += directionalLight_currentRayDirection * singleVoxelSize;

                if (iterationIndex >= SURFACE_OCCLUSION_SKIP_ITERATION)
                {
                    float3 directionalLight_scaledRayPosition = ((directionalLight_currentRayPosition + (VolumeSize / 2.0)) - VolumePosition) / VolumeSize;
                    float4 directionalLight_sceneAlbedoSample = TEX3D_SHARP(SceneAlbedo, directionalLight_scaledRayPosition);

                    if (directionalLight_sceneAlbedoSample.a > 0.0)
                    {
                        directionalLight_isOccluded = true;
                        break;
                    }
                }

                iterationIndex++;
            }

            if (directionalLight_isOccluded == false)
            {
                finalColor.rgb += directionalLightColorSample;
            }
        }
    #endif

    //|||||||||||||||||||||||||||||||||||| SPOT LIGHTS ||||||||||||||||||||||||||||||||||||
    //|||||||||||||||||||||||||||||||||||| SPOT LIGHTS ||||||||||||||||||||||||||||||||||||
    //|||||||||||||||||||||||||||||||||||| SPOT LIGHTS ||||||||||||||||||||||||||||||||||||
    #if defined (SPOT_LIGHTS)
        for (int x = 0; x < SpotLights.Length; x++)
        {
            LightSpot spotLight = SpotLights[x];

            float distanceToSpotLight = distance(worldVoxelPosition, spotLight.lightPosition);
            float spotLightDistanceSample = CalculateAttenuation(distanceToSpotLight);
            float3 spotLightWorldDirection = normalize(worldVoxelPosition - spotLight.lightPosition);

            // Calculate the cosine of the angle corresponding to the spot light's cone angle
            float cosConeAngle = cos(radians(spotLight.lightAngle / 2.0));

            // Calculate the spot light influence (0.0 to 1.0) based on the angle between the light direction and the spotlight direction
            float spotLightAngle = saturate((dot(spotLightWorldDirection, spotLight.lightDirection) - cosConeAngle) / (1.0 - cosConeAngle));

            // Calculate the spot light range influence
            float spotLightRange = saturate(1.0 - (distanceToSpotLight / spotLight.lightRange));

            float3 spotLight_currentRayPosition = worldVoxelPosition;
            float3 spotLight_currentRayDirection = -spotLightWorldDirection;
            float3 spotLightColorSample = spotLight.lightColor * spotLight.lightIntensity;

            //------------------------------ DIRECT LIGHT ------------------------------
            //------------------------------ DIRECT LIGHT ------------------------------
            //------------------------------ DIRECT LIGHT ------------------------------

            bool spotLight_isOccluded = false;
            float3 spotLight_hitPosition = float3(0, 0, 0);
            float3 spotLight_hitNormal = float3(0, 1, 0);
            float3 spotLight_hitAlbedo = float3(1, 1, 1);

            iterationIndex = 0;

            while (distance(spotLight_currentRayPosition, spotLight.lightPosition) > 0.5f)
            {
                if (PositionInVolumeBounds(spotLight_currentRayPosition.xyz) == false)
                    break;

                //keep stepping the ray in world space
                //spotLight_currentRayPosition += spotLight_currentRayDirection / length(VolumeResolution);
                spotLight_currentRayPosition += spotLight_currentRayDirection * singleVoxelSize;

                if (iterationIndex >= SURFACE_OCCLUSION_SKIP_ITERATION)
                {
                    float3 spotLight_scaledRayPosition = ((spotLight_currentRayPosition + (VolumeSize / 2.0)) - VolumePosition) / VolumeSize;
                    float4 spotLight_sceneAlbedoSample = TEX3D_SHARP(SceneAlbedo, spotLight_scaledRayPosition);

                    if (spotLight_sceneAlbedoSample.a > 0.0)
                    {
                        spotLight_isOccluded = true;
                        break;
                    }
                }

                iterationIndex++;
            }

            if (spotLight_isOccluded == false)
            {
                finalColor.rgb += spotLightColorSample * spotLightDistanceSample * spotLightAngle * spotLightRange;
            }
        }
    #endif

    //|||||||||||||||||||||||||||||||||||| POINT LIGHTS ||||||||||||||||||||||||||||||||||||
    //|||||||||||||||||||||||||||||||||||| POINT LIGHTS ||||||||||||||||||||||||||||||||||||
    //|||||||||||||||||||||||||||||||||||| POINT LIGHTS ||||||||||||||||||||||||||||||||||||
    #if defined (POINT_LIGHTS)
        for (int y = 0; y < PointLights.Length; y++)
        {
            LightPoint pointLight = PointLights[y];

            float distanceToPointLight = distance(worldVoxelPosition, pointLight.lightPosition);
            float3 pointLightColorSample = pointLight.lightColor * pointLight.lightIntensity;
            float pointLightDistanceSample = CalculateAttenuation(distanceToPointLight);

            float pointLightRange = saturate(1.0 - (distanceToPointLight / pointLight.lightRange));

            float3 pointLightWorldDirection = normalize(worldVoxelPosition - pointLight.lightPosition);

            float3 pointLight_currentRayPosition = worldVoxelPosition;
            float3 pointLight_currentRayDirection = -pointLightWorldDirection;

            bool pointLight_isOccluded = false;

            iterationIndex = 0;

            while (distance(pointLight_currentRayPosition, pointLight.lightPosition) > 0.5f)
            {
                if (PositionInVolumeBounds(pointLight_currentRayPosition.xyz) == false)
                    break;

                //keep stepping the ray in world space
                //pointLight_currentRayPosition += pointLight_currentRayDirection / length(VolumeResolution);
                pointLight_currentRayPosition += pointLight_currentRayDirection * singleVoxelSize;

                if (iterationIndex >= SURFACE_OCCLUSION_SKIP_ITERATION)
                {
                    float3 pointLight_scaledRayPosition = ((pointLight_currentRayPosition + (VolumeSize / 2.0)) - VolumePosition) / VolumeSize;
                    float pointLight_sceneOcclusionSample = TEX3D_SHARP(SceneAlbedo, pointLight_scaledRayPosition).a;

                    if (pointLight_sceneOcclusionSample > 0.0)
                    {
                        pointLight_isOccluded = true;
                        break;
                    }
                }

                iterationIndex++;
            }

            if (pointLight_isOccluded == false)
            {
                //finalColor.rgb += pointLightColorSample * pointLightDistanceSample;
                finalColor.rgb += pointLightColorSample * pointLightDistanceSample * pointLightRange;
            }
        }
    #endif

    finalColor = max(0.0f, finalColor);
    finalColor.rgb += float3(0.1f, 0.1f, 0.1f);
    finalColor *= sceneAlbedo;
    finalColor += sceneEmissive;

    Write[id.xyz] = finalColor;
}
